* ;;
#+Title: radish
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results value :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure            {:mvn/version "1.10.3"}
  org.clojure/tools.cli          {:mvn/version "1.0.206"}
  hiccup/hiccup                  {:mvn/version "2.0.0-alpha2"}
  io.github.adam-james-v/svg-clj {:mvn/version "0.0.3-SNAPSHOT"}
  orgmode/orgmode {:git/url "https://github.com/bnbeckwith/orgmode"
                   :sha "722972c72b43c18a5cdbbc9c3e392b5ee9e2b503"}

  ;; deps for shadow-cljs compilation
  thheller/shadow-cljs    {:mvn/version "2.14.0"}
  borkdude/sci            {:mvn/version "0.2.6"}
  reagent/reagent         {:mvn/version "1.0.0"}
  cljsjs/react            {:mvn/version "17.0.2-0"}
  cljsjs/react-dom        {:mvn/version "17.0.2-0"}
  cljsjs/react-dom-server {:mvn/version "17.0.2-0"}}
 
 :paths ["src" "resources"]
 
 :aliases
 {:test
  {:extra-paths ["test"]
   :extra-deps {org.clojure/test.check {:mvn/version "1.1.0"}
                com.cognitect/test-runner
                {:git/url "https://github.com/cognitect-labs/test-runner.git"
                 :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
   :main-opts ["-m" "cognitect.test-runner"]}
  
  :uberjar
  {:replace-deps {com.github.seancorfield/depstar {:mvn/version "2.1.245"}}
   :exec-fn hf.depstar/uberjar
   :exec-args {:jar radish.jar
               :main-class radish.main
               :aot true}}}}
#+end_src

** bb.edn
#+begin_src clojure :tangle ./bb.edn
{:tasks
 {:requires ([babashka.fs :as fs]
             [clojure.string :as str])
  :init (def windows? (str/starts-with? (System/getProperty "os.name")
                                        "Windows"))
  run-main
  {:doc "Run main"
   :task (apply clojure "-M -m radish.main" *command-line-args*)}
  
  uberjar
  {:doc "Builds uberjar"
   :task (when (seq (fs/modified-since "radish.jar" "src"))
           (clojure "-X:uberjar"))}

  -shadow
  {:task (clojure "-M:dev -m shadow.cljs.devtools.cli release main")}

  run-uber
  {:doc "Run uberjar"
   :depends [uberjar]
   :task (apply shell "java -jar radish.jar" *command-line-args*)}
  
  -graalvm
  {:doc "Checks GRAALVM_HOME env var"
   :task
   (let [env (System/getenv "GRAALVM_HOME")]
     (assert "Set GRAALVM_HOME")
     env)}
  
  -gen-reflect-config
  {:doc "Runs scripts/gen-reflect-config.clj on the compiled jar."
   :depends [-graalvm uberjar]
   :task (binding [*command-line-args* ["java" "-jar" "radish.jar" "-i" "radish-basic.org"]]
           (load-file "scripts/gen-reflect-config.clj"))}

  -clean-build
  {:doc "Cleans up Native Image compilation artifacts"
   :task (do
           (shell "rm" "-rf" "radish-basic-example")
           (shell "rm" "-f" "radish.jar")
           (shell "rm" "-rf" "build/tmp")
           (shell "rm" "-f" "trace-file.json")
           (shell "rm" "-f" "radish.build_artifacts.txt"))}

  native-image
  {:doc "Builds native image"
   :depends [-clean-build -graalvm uberjar -gen-reflect-config]
   :task (do
           (shell "mkdir" "-p" "build/tmp")
           (shell (str (fs/file -graalvm
                                "bin"
                                (if windows?
                                  "gu.cmd"
                                  "gu")))
                  "install" "native-image")
           (shell (str (fs/file -graalvm
                                "bin"
                                (if windows?
                                  "native-image.cmd"
                                  "native-image")))
                  "-H:Name=radish"
                  "-H:ReflectionConfigurationFiles=build/tmp/reflect-config-cleaned.json"
                  "-H:ResourceConfigurationFiles=resource-config.json"
                  "-jar" "radish.jar"
                  "--initialize-at-build-time"
                  "--no-fallback"
                  "--no-server")
           (run '-clean-build)
           (shell "mv" "-f" "./radish" "./build/radish"))}}}

#+end_src

** build-resources
Use these scripts to help with the native-image build process. Jar/uberjar builds work just fine with bb tasks already.

*** gen-reflect-script
Use these scripts to help with the native-image build process. Jar/uberjar builds work just fine with bb tasks already.

This script is from borkdude's example repo:

[[https://github.com/borkdude/refl/blob/main/script/gen-reflect-config.clj]]

This script takes a reflect-config.json and cleans it up by removing unnecessary clojure classes and fixing the bug(?) where java.lang.reflect.Method causes native-image to fail at setup phase.

#+begin_src clojure :tangle ./scripts/gen-reflect-config.clj
#!/usr/bin/env bb

(require '[babashka.process :refer [process]]
         '[cheshire.core :as cheshire]
         '[clojure.string :as str]
         '[clojure.java.shell :refer [sh]])

(def trace-cmd *command-line-args*)

(def trace-agent-env "-agentlib:native-image-agent=trace-output=trace-file.json")
(def config-agent-env "-agentlib:native-image-agent=config-output-dir=build/tmp")

@(process trace-cmd {:inherit true :extra-env {"JAVA_TOOL_OPTIONS" trace-agent-env}})
@(process trace-cmd {:inherit true :extra-env {"JAVA_TOOL_OPTIONS" config-agent-env}})

(def trace-json (cheshire/parse-string (slurp "trace-file.json") true))

(defn normalize-array-name [n]
  ({"[F" "float[]"
    "[B" "byte[]"
    "[Z" "boolean[]"
    "[C" "char[]"
    "[D" "double[]"
    "[I" "int[]"
    "[J" "long[]"
    "[S" "short[]"} n n))

(def ignored (atom #{}))
(def unignored (atom #{}))

(defn ignore [{:keys [:tracer :caller_class :function :args] :as _m}]
  (when (= "reflect" tracer)
    (when-let [arg (first args)]
      (let [arg (normalize-array-name arg)]
        (if (and caller_class
                 (or (= "clojure.lang.RT" caller_class)
                     (= "clojure.genclass__init" caller_class)
                     (and (str/starts-with? caller_class "clojure.core$fn")
                          (= "java.sql.Timestamp" arg)))
                 (= "forName" function))
          (swap! ignored conj arg)
          (when (= "clojure.lang.RT" caller_class)
            ;; unignore other reflective calls in clojure.lang.RT
            (swap! unignored conj arg)))))))

(run! ignore trace-json)

;; (prn @ignored)
;; (prn @unignored)

(defn process-1 [{:keys [:name] :as m}]
  (when-not (and (= 1 (count m))
                 (contains? @ignored name)
                 (not (contains? @unignored name)))
    ;; fix bug(?) in automated generated config
    (if (= "java.lang.reflect.Method" name)
      (assoc m :name "java.lang.reflect.AccessibleObject")
      m)))

(def config-json (cheshire/parse-string (slurp "build/tmp/reflect-config.json") true))

(def cleaned (keep process-1 config-json))

(spit "build/tmp/reflect-config-cleaned.json" (cheshire/generate-string cleaned {:pretty true}))
(shutdown-agents)
#+end_src

*** resource-config
#+begin_src json :tangle ./resource-config.json
{
  "resources": [
     {"pattern": "style.css"},
     {"pattern": "codemirror.css"},
     {"pattern": "nord.css"},
     {"pattern": "codemirror.js"},
     {"pattern": "clojure.js"},
     {"pattern": "code-runner.cljs"}
  ]
}
#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
<img src="https://github.com/adam-james-v/radish/blob/main/doc/radish.svg" alt="A flat-style vecor illustration of a radish." width="300">

# Radish
A kinda-cool org-mode -> interactive blog post tool written with and for Clojure(script).

Here are two example posts created with this tool:

<a href="https://adam-james-v.github.io/posts/radish-basic-example/index.html">Radish Basic Example</a> - (Basic Build) Uses Scittle with no external dependencies incorporated into the build.


<a href="https://adam-james-v.github.io/posts/radish-logo/index.html">Radish Logo</a> - (Advanced Build) Uses Radish to automatically create and compile a shadow-cljs project to incorporate external CLJS dependencies into the (cloned) Scittle interpreter.


## Why Radish?
A friend sent me a meme about radishes while I was thinking of a name for this project. I chuckled, then figured it's a good enough name for a small project like this.

## Usage
If you have a recent installation of [Babashka](https://github.com/babashka/babashka), you can run a few useful babashka tasks.

 - `bb run-main -i your-org-file.org` -> run the src with clojure
 - `bb run-uber -i your-org-file.org` -> build and run an uberjar with 
 - `bb uberjar` -> create **radish.jar** in the project root directory without running

Once you've built the uberjar, you can use it via:

`java -jar radish.jar -i your-org-file.org`

If you don't have or want to use Babashka, the following commands should work:

 - `clojure -M -m radish.main -i your-org-file.org` -> run the src with clojure
 - `clojure -X:uberjar` -> build the uberjar
 - `java -jar radish.jar -i your-org-file.org` -> run the uberjar, as stated previously.

Radish will create a directory in the same dir as the org file, with a name derived from the Title of the org file. Inside will be all necessary .js and .css files alongside a generated index.html. You should be able to upload this directory to your site and have a working page.

## Compiling to Native Image
You can compile this project with GraalVM's native-image.

First, make sure you have GraalVM / native-image installed, then set your env variables:

```
export GRAALVM_HOME=/Users/adam/Downloads/graalvm-ce-java11-21.1.0/Contents/Home
export JAVA_HOME=$GRAALVM_HOME 

```

NOTE: Change the path to match where you've downloaded/installed GraalVM

Then, run the native-image task with Babashka.

`bb native-image`

If the build succeeds, you should find the binary in `build/radish`.

NOTE: This is still fairly new territory for me, so the build script(s) could likely be cleaned up a bit yet. However, the final binary should work the same as the src or uberjar.

`./radish -i your-org-file.org`

## Current Limitations
The only build method so far is 'basic-build', which relies on a simple script executed in your browser by scittle after the page loads. It has no dependency loading capabilities and thus is limited to executing Clojurescript code that only relies on core libraries.

A more complete build process is underway where the idea is to compile dependencies using the Clojurescript compiler and creating a page via that process.

#+END_SRC

* design
The goal of this tool is to create a publishable directory (html, js, css combo) from an org-mode file containing Clojure(script) code blocks.

The idea is to make a graalvm native-image tool that takes the org file and emits the directory with everything that is necessary to run things client-side in a browser.

To do this, the following things have to happen:

 - parse org-mode file
 - exclude all exclusion tags, clean up any weirdness
 - extract all clj/cljs dependencies
 - convert into hiccup structure
 - build cljs project (from template?)
 - compile cljs project, including all necessary js, css in output dir

* resources
** css
#+BEGIN_SRC css :tangle ./resources/shared/style.css
/*
:root {
  --bg: #ffecdc;
  --col01: #ffbae1;
  --col02: #bd6cea;
  --col03: #ff42b4;
  --col04: #5671ff;
}
,*/

html {
  background-color: var(--bg);
}

#root {
  margin: 0;
  padding: 0;
}

,*, *:after, *:before {
  box-sizing: border-box;
}

body {
  font: 17px/1.375 Georgia, "Times New Roman", Times, serif;
  width: 100%;
  margin: 0;
}

main {
  max-width: 620px;
  margin: 0 auto;
  padding: 20px 0 100px 0;
  color: #222;
}

@media only screen and (max-width: 600px) {
  main {
    margin: 0 12px;
  }
}

header {
  color: #ffeeff;
  font-size: 1.75em;
  width: 100%;
  height: 280px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  background-image: linear-gradient(to bottom right, var(--col01), var(--col02));
  box-shadow: inset 0px -15px 28px -15px #666;
}

/*
header h1 {
  text-shadow: 1px 1px rgba(250,250,250,0.1);
  background: linear-gradient(to top right, var(--col03), var(--col04));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
,*/

header h1 {
  text-shadow: 1px 1px rgba(25,20,25,0.15);
}

footer {
  color: #ffeeff;
  width: 100%;
  height: 280px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-flow: column;
  background-image: linear-gradient(to bottom right, var(--col02), var(--col01));
  box-shadow: inset 0px 15px 28px -15px #666;
  text-shadow: 1px 1px rgba(0,0,0,0.4);
}
                
.code-container {
  font-size: 14px;
  margin: 35px auto;
  border-radius: 11px 11px 11px 11px;
  box-shadow: 0px 2px 8px 0px rgba(20, 20, 20, 0.2);
  -moz-box-shadow: 0px 2px 8px 0px rgba(20, 20, 20, 0.2);
  -webkit-box-shadow: 0px 2px 8px 0px rgba(20, 20, 20, 0.2);
  -o-box-shadow: 0px 2px 8px 0px rgba(20, 20, 20, 0.2);
}

.code-container pre {
  margin-top: 0;
}

.code-container .src-clojure-ref {
  background-color: #777;
  font-size: 13px;
  border-radius: 11px 11px 11px 11px;
}

.CodeMirror {
  padding-top: 10px;
  border-radius: 11px 11px 0 0;
}

.result {
  background: rgba(120,120,120,0.15);
}

.result .render {
  padding: 10px;
}

.result code {
  display: inline-block;
  max-height: 180px;
  overflow-y: auto;
}

pre {
  padding: 12px;
  white-space: pre-wrap;
}

table, input {
  font-size: 16px;
}

h1, h2, h3, h4, h5, h6 {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.2;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
  text-align: left;
  padding-bottom: 25px;
  width: auto;
}

th, td {
  vertical-align: top;
  padding: 5px;
  border: 1px solid #ddd;
}

table ul {
  list-style-type: none;
  padding-left: 4px;
  margin: 0;
}

table p {
  margin: 0;
}

td, th {
  padding: 5px;
  vertical-align: bottom;
}

td, th, hr {
  border-bottom: 1px solid #ddd;
}

hr {
  border: 0;
  margin: 25px 0;
}

.hidden {
  display: none;
}

a {
  color: var(--col03);
  text-decoration: none;
}

a:hover {
  color: var(--col04);
  text-decoration: underline;
}

button, select {
  font-size: 14px;
  background: #ddd;
  border: 0;
  padding: 9px 20px;
}

input {
  padding: 3px;
  vertical-align: bottom;
}

button:hover {
  background: #eee;
}

textarea {
  border-color: #ccc;
}
#+END_SRC

** code-runner
This script is embedded into the index.html file and is responsible for 'building' and evaluating the src blocks in the base site.

The code runner itself is evaluated and run via scittle for a basic site output and radish.core (a clone of scittle with additional deps. automatically compiled in) for an advanced build.

NOTE: When using radish.core, the code-runner source string has one single modification:

in ~result-component~, ~js/scittle.core.eval_string~ is turned into ~js/radish.core.eval_string~. Everything else is identical.

#+begin_src clojure :tangle ./resources/code-runner.cljs
(require '[reagent.core :as r]
         '[reagent.dom :as rdom])

(defn editor
  [id ns-str state]
  (let [cm (.fromTextArea  js/CodeMirror
                           (.getElementById js/document id)
                           #js {:mode "clojure"
                                :theme "nord"
                                :lineNumbers true
                                :smartIndent true
                                :tabSize 2})]
    (.on cm "change" (fn [_ _]
                       (reset! state (str ns-str (.getValue cm)))))
    (.setSize cm "auto" "auto")))

(defn renderable-element?
  [elem]
  (and (vector? elem)
       (keyword? (first elem))
       (not= (str (first elem)) ":")
       (not (str/includes? (str (first elem)) "/"))
       (not (re-matches #"[0-9.#].*" (name (first elem))))
       (re-matches #"[a-zA-Z0-9.#]+" (name (first elem)))))

(defn renderable?
  [elem]
  (when (or (renderable-element? elem) (seq? elem))
    (let [[k props content] elem
          [props content] (if (and (nil? content)
                                   (not (map? props)))
                            [nil props]
                            [props content])]
      (cond
        (seq? elem) (not (empty? (filter renderable? elem)))
        (seq? content) (not (empty? (filter renderable? content)))
        :else (or (renderable-element? content)
                  (renderable-element? elem)
                  (string? content)
                  (number? content))))))

(defn result-component
  [ns-str state]
  (fn [ns-str state]
    (let [result (try (js/scittle.core.eval_string (str ns-str @state))
                      (catch :default e
                        (.-message e)))]
      [:div.result
       [:pre
        [:div "RESULT:"]
        (when (renderable? result) [:div.render result])
        [:code (if result (str result) "nil")]]])))

(def current-ns (atom `'~'user))

(defn contains-ns?
  [s]
  (str/includes? s "(ns "))

(defn extract-ns
  [src-str]
  (->> src-str
       (#(str "[" % "]"))
       read-string
       (filter (fn [[sym & _]] (= sym 'ns))) ;; drop any code that isn't a ns decl
       last
       second))

(defn run-src
  [elem]
  (let [id (gensym "src-")
        src-str (.-innerText elem)
        parent (.-parentNode elem)
        this-ns (if (contains-ns? src-str)
                  `'~(extract-ns src-str)
                  @current-ns)
        ns-str (str "(in-ns " this-ns ")\n")
        state (r/atom src-str)]
    (reset! current-ns this-ns) 
    (rdom/render [:textarea {:id id} src-str] parent)
    (editor id ns-str state)
    (rdom/render [result-component ns-str state] parent)))

(defn run! []
  (let [blocks (vec (.getElementsByClassName js/document "src-clojure"))]
    (mapv run-src blocks)))

(run!)
#+end_src

** advanced-build-srcs
These sources are nearly identitcal to the scittle src code.
The reason they are used here is to allow shadow-cljs to compile js artifacts that incorporate the deps/namespaces found by radish.

Basically, an 'advanced' radish build will automatically generate a scittle clone project, adding the user's namespace requirements into the eval context. Then, shadow-cljs runs on this project, emitting radish.js and radish.reagent.js (the latter should always be unchanged), which can then be treated just like the scittle sources for a 'basic' build.

*** error
#+begin_src clojure :tangle ./resources/advanced/error.cljs
(ns radish.error
  (:refer-clojure :exclude [println])
  (:require [clojure.string :as str]
            [sci.impl.callstack :as cs]))

(defn println [& strs]
  (.error js/console (str/join " " strs)))

(defn ruler [title]
  (println (apply str "----- " title " " (repeat (- 50 7 (count title)) \-))))

(defn split-stacktrace [stacktrace verbose?]
  (if verbose? [stacktrace]
      (let [stack-count (count stacktrace)]
        (if (<= stack-count 10)
          [stacktrace]
          [(take 5 stacktrace)
           (drop (- stack-count 5) stacktrace)]))))

(defn print-stacktrace
  [stacktrace {:keys [:verbose?]}]
  (let [stacktrace (cs/format-stacktrace stacktrace)
        segments (split-stacktrace stacktrace verbose?)
        [fst snd] segments]
    (run! #(print % "\n") fst)
    (when snd
      (print "...\n")
      (run! #(print % "\n") snd))))

(defn error-context [ex src-map]
  (let [{:keys [:file :line :column]} (ex-data ex)]
    (when (and file line)
      (when-let [content (get src-map file)]
        (let [matching-line (dec line)
              start-line (max (- matching-line 4) 0)
              end-line (+ matching-line 6)
              [before after] (->>
                              (str/split-lines content)
                              (map-indexed list)
                              (drop start-line)
                              (take (- end-line start-line))
                              (split-at (inc (- matching-line start-line))))
              snippet-lines (concat before
                                    [[nil (str (str/join "" (repeat (dec column) " "))
                                               (str "^--- " (ex-message ex)))]]
                                    after)
              indices (map first snippet-lines)
              max-size (reduce max 0 (map (comp count str) indices))
              snippet-lines (map (fn [[idx line]]
                                   (if idx
                                     (let [line-number (inc idx)]
                                       (str (.padStart (str line-number) max-size "0") "  " line))
                                     (str (str/join (repeat (+ 2 max-size) " ")) line)))
                                 snippet-lines)]
          (str "\n" (str/join "\n" snippet-lines)))))))

(defn right-pad [s n]
  (let [n (- n (count s))]
    (str s (str/join (repeat n " ")))))

(defn print-locals [locals]
  (let [max-name-length (reduce max 0 (map (comp count str)
                                           (keys locals)))
        max-name-length (+ max-name-length 2)]
    (println
     (with-out-str (binding [*print-length* 10
                             ,*print-level* 2]
                     (doseq [[k v] locals]
                       (print (str (right-pad (str k ": ") max-name-length)))
                       ;; print nil as nil
                       (prn v)))))))

(defn error-handler [e src-map]
  (let [d (ex-data e)
        sci-error? (isa? (:type d) :sci/error)
        stacktrace (some->
                    d :sci.impl/callstack
                    cs/stacktrace)]
    (ruler "Scittle error")
    (when-let [name (.-name e)]
      (when-not (= "Error" name)
        (println "Type:    " name)))
    (when-let [m (.-message e)]
      (println (str "Message:  " m)))
    (when-let [d (ex-data (ex-cause e) #_(.getCause e))]
      (print (str "Data:     "))
      (prn d))
    (let [{:keys [:file :line :column]} d]
      (when line
        (println (str "Location: "
                      (when file (str file ":"))
                      line ":" column""))))
    (when-let [phase (cs/phase e stacktrace)]
      (println "Phase:   " phase))
    (when-let [ec (when sci-error?
                      (error-context e src-map))]
        (ruler "Context")
        (println ec))
    (when-let [locals (not-empty (:locals d))]
      (ruler "Locals")
      (print-locals locals))
    (when sci-error?
      (when-let
          [st (let [st (with-out-str
                         (when stacktrace
                           (print-stacktrace stacktrace src-map)))]
                (when-not (str/blank? st) st))]
        (ruler "Stack trace")
        (println st)))))

#+end_src

*** core
#+begin_src clojure :tangle ./resources/advanced/core.cljs
(ns radish.core
  (:refer-clojure :exclude [time])
  (:require [goog.object :as gobject]
            [goog.string]
            [sci.core :as sci]
            [radish.error :as error]
            [cljs.reader :refer [read-string]]
            ;; radish.radns is generated based on deps/ns declarations in org file
            [radish.radns :refer [my-ns-map]]))

(clojure.core/defmacro time
  "Evaluates expr and prints the time it took. Returns the value of expr."
  [expr]
  `(let [start# (cljs.core/system-time)
         ret# ~expr]
     (prn (cljs.core/str "Elapsed time: "
                         (.toFixed (- (system-time) start#) 6)
                         " msecs"))
     ret#))

(def stns (sci/create-ns 'sci.script-tag nil))
(def cljns (sci/create-ns 'clojure.core nil))
(def rns (sci/create-ns 'cljs.reader nil))

(def namespaces
  (merge 
   {'clojure.core
    {'println     println
     'prn         prn
     'system-time system-time
     'time        (sci/copy-var time cljns)
     'random-uuid random-uuid
     'read-string (sci/copy-var read-string rns)}
    'goog.object {'set gobject/set
                  'get gobject/get}}
   my-ns-map))

(def ctx (atom (sci/init {:namespaces namespaces
                          :classes {'js js/window
                                    :allow :all}
                          :disable-arity-checks true})))

(defn ^:export eval-string [s]
  (try (sci/eval-string* @ctx s)
       (catch :default e
         (error/error-handler e (:src @ctx))
         (let [sci-error? (isa? (:type (ex-data e)) :sci/error)]
           (throw (if sci-error?
                    (or (ex-cause e) e)
                    e))))))

(defn register-plugin! [plug-in-name sci-opts]
  plug-in-name ;; unused for now
  (swap! ctx sci/merge-opts sci-opts))

(defn- eval-script-tags* [script-tags]
  (when-let [tag (first script-tags)]
    (if-let [text (not-empty (gobject/get tag "textContent"))]
      (let [scittle-id (str (gensym "scittle-tag-"))]
        (gobject/set tag "scittle_id" scittle-id)
        (swap! ctx assoc-in [:src scittle-id] text)
        (sci/binding [sci/file scittle-id]
          (eval-string text))
        (eval-script-tags* (rest script-tags)))
      (let [src (.getAttribute tag "src")
            req (js/XMLHttpRequest.)
            _ (.open req "GET" src true)
            _ (gobject/set req "onload"
                           (fn [] (this-as this
                                    (let [response (gobject/get this "response")]
                                      (gobject/set tag "scittle_id" src)
                                      ;; save source for error messages
                                      (swap! ctx assoc-in [:src src] response)
                                      (sci/binding [sci/file src]
                                        (eval-string response)))
                                    (eval-script-tags* (rest script-tags)))))]
        (.send req)))))

(defn ^:export eval-script-tags []
  (let [script-tags (js/document.querySelectorAll "script[type='application/x-scittle']")]
    (eval-script-tags* script-tags)))

(def auto-load-disabled? (volatile! false))

(defn ^:export disable-auto-eval
  "By default, scittle evaluates script nodes on the DOMContentLoaded
  event using the eval-script-tags function. This function disables
  that behavior."
  []
  (vreset! auto-load-disabled? true))

(js/document.addEventListener
 "DOMContentLoaded"
 (fn [] (when-not @auto-load-disabled? (eval-script-tags))), false)
#+end_src

*** reagent
#+begin_src clojure :tangle ./resources/advanced/reagent.cljs
(ns radish.reagent
  (:require [reagent.core :as r]
            [reagent.dom :as rdom]
            [sci.core :as sci]
            [radish.core :as rad]))

(def rns (sci/create-ns 'reagent.core nil))

(def reagent-namespace
  {'atom (sci/copy-var r/atom rns)
   'as-element (sci/copy-var r/as-element rns)})

(def rdns (sci/create-ns 'reagent.dom nil))

(def reagent-dom-namespace
  {'render (sci/copy-var rdom/render rdns)})

(rad/register-plugin!
 ::reagent
 {:namespaces {'reagent.core reagent-namespace
               'reagent.dom reagent-dom-namespace}})
#+end_src

* main
** ns
#+begin_src clojure :tangle ./src/radish/main.clj
(ns radish.main
  (:require [clojure.string :as str]
            [clojure.zip :as zip]
            [clojure.java.shell :refer [sh]]
            [clojure.tools.cli :as cli]
            [hiccup.core :refer [html]]
            [hiccup.page :as page]
            [orgmode.core :as org]
            [orgmode.html :refer [hiccupify *user-src-fn*]]
            [shadow.cljs.devtools.api :as shadow]
            [shadow.cljs.devtools.server :as server])
  (:gen-class))
#+end_src

** tree-edit
#+begin_src clojure :tangle ./src/radish/main.clj
;; https://ravi.pckl.me/short/functional-xml-editing-using-zippers-in-clojure/
(defn tree-edit
  [zipper matcher editor]
  (loop [loc zipper]
    (if (zip/end? loc)
      (zip/root loc)
      (if-let [matcher-result (matcher loc)]
        (let [new-loc (zip/edit loc editor)]
          (if (not (= (zip/node new-loc) (zip/node loc)))
            (recur (zip/next new-loc))
            (recur (zip/next loc))))
        (recur (zip/next loc))))))

(defn get-nodes
  [zipper matcher]
  (loop [loc zipper
         acc []]
    (if (zip/end? loc)
      acc
      (if (matcher loc)
        (recur (zip/next loc) (conj acc (zip/node loc)))
        (recur (zip/next loc) acc)))))

#+end_src

** node-matchers
#+begin_src clojure :tangle ./src/radish/main.clj
(defn match-src?
  [loc]
  (let [node (zip/node loc)
        {:keys [block]} node]
    (= block :src)))

(defn match-result?
  [loc]
  (let [node (zip/node loc)
        s (-> node :content first)]
    (when s
      (str/starts-with?
       (str/upper-case s)
       "#+RESULT"))))

(defn match-deps?
  [loc]
  (let [node (zip/node loc)
        {:keys [type content]} node]
    (and (= type :block)
         (str/includes? (apply str content) ":deps"))))

(defn match-ns?
  [loc]
  (let [node (zip/node loc)
        {:keys [type content]} node
        fl (->> content
                (filter string?)
                (filter #(not= (str/trim %) ""))
                first)]
    (and (= type :block)
         (str/starts-with? fl "(ns"))))

(defn match-headlines?
  [loc]
  (let [node (zip/node loc)]
    (= (:type node) :headline)))

#+end_src

** tree-node-editors
#+begin_src clojure :tangle ./src/radish/main.clj
;; don't remove the entire node as the #+RESULT is within a paragraph
;; which means there may be required content following the results.
(defn- remove-result
  [node]
  (let [new-content (drop 2 (:content node))]
    (assoc node :content (vec new-content))))

(defn remove-results
  [org]
  (let [org-zipper (org/zip org)]
    (tree-edit org-zipper match-result? remove-result)))

(defn- retag-deps-node
  [node]
  (let [new-attribs ["clojure-ref"]]
    (assoc node :attribs new-attribs)))

(defn retag-deps
  [org]
  (let [org-zipper (org/zip org)]
    (tree-edit org-zipper match-deps? retag-deps-node)))

#+end_src

** getters
#+begin_src clojure :tangle ./src/radish/main.clj
(defn get-headlines
  [org]
  (map :text (get-nodes (org/zip org) match-headlines?)))

(defn get-title
  [org-str]
  (let [lines (str/split-lines org-str)
        headlines (filter #(not (str/starts-with? % ";"))
                          (get-headlines (org/parse-str org-str)))
        f #(str/starts-with? (str/upper-case %) "#+TITLE")
        title (->> lines (filter f) first)]
    (if title
      (str/join " " (-> title (str/split #" ") rest))
      (first headlines))))

(defn safe-name
  [title]
  (-> title
      str/lower-case
      (str/replace #";" "-")
      (str/replace #" " "-")))

(defn get-author
  [org-str]
  (let [lines (str/split-lines org-str)
        f #(str/starts-with? (str/upper-case %) "#+AUTHOR")
        title (->> lines
                   (filter f)
                   first)]
    (when title
      (str/join " " (-> title (str/split #" ") rest)))))

(defn get-deps
  [org-str]
  (-> org-str
      org/parse-str
      org/zip
      (get-nodes match-deps?)
      first
      :content
      (->> (apply str))
      read-string
      (#(apply dissoc % (remove #{:deps} (keys %))))))

;; we abuse org-mode syntax only once for allowing inline radish config.
;; we just add 'radish-config' to a src block and we can get it via the attribs list
;; it means nothing in org-mode context, but will also not cause issues (I am pretty sure)
(defn get-radish-config
  [org-str]
  (let [srcs (-> org-str
                 org/parse-str
                 org/zip
                 (get-nodes match-src?)
                 (->> (filter
                       (fn [{:keys [attribs]}]
                         (not (empty? (filter #{"radish-config"} attribs)))))))]
    (if (empty? srcs)
      {}
      (->> srcs
           first
           :content
           (apply str)
           (#(str/replace % "'" "")) ;; hack to prevent (quote 'sym) issue. in comment-src-ndes
           read-string))))

#+end_src

** namespace-editor
#+begin_src clojure :tangle ./src/radish/main.clj
(defn- keep-require
  [ns-form]
  (first
   (filter
    (fn [el]
      (when (seq? el)
        (= (first el) :require)))
    ns-form)))

;; NOTE: potentially I should make this return a map to capture refers, aliases, exludes, etc.
(defn get-namespace-requires
  "Returns a vector of all required namespaces from all ns declarations, dropping aliases, refers, excludes."
  [org-str]
  (let [nodes-list (-> org-str
                       org/parse-str
                       org/zip
                       (get-nodes match-ns?))]
    (->> nodes-list
         (mapcat :content)
         (apply str)
         (#(str "[" % "]"))
         read-string
         (filter (fn [[sym & _]] (= sym 'ns))) ;; drop any code that isn't a ns decl
         (map keep-require)
         (mapcat rest)
         (map first)
         (into #{})
         vec)))

(def blacklisted-namespaces
  #{'hiccup.core
    'clojure.java.shell})

(defn- blacklisted?
  [req-entry]
  (blacklisted-namespaces (first req-entry)))

(defn- clean-namespace-decl
  [node]
  (let [to-remove (map name blacklisted-namespaces)
        src (->> node
                 :content
                 (apply str)
                 (#(str "[" % "]"))
                 read-string)
        ns-decl (->> src
                     (filter (fn [[sym & _]] (= sym 'ns)))
                     first
                     vec)
        ns-decl-idx (->> src
                         (take-while (fn [[sym & _]] (= sym 'ns)))
                         count
                         dec)
        req-idx (->> ns-decl
                     (take-while #(not (when (seqable? %) (= (first %) :require))))
                     count)
        reqs (->> ns-decl
                  (filter #(when (seqable? %) (= (first %) :require)))
                  first
                  rest
                  (remove blacklisted?)
                  (into '[:require])
                  (apply list))
        xf-ns-decl (apply list (assoc ns-decl req-idx reqs))
        xf-src (apply list (assoc src ns-decl-idx xf-ns-decl))
        xf-src-str (apply str (map #(with-out-str (clojure.pprint/pprint %)) xf-src))
        xf-content (-> xf-src-str
                       (str/replace "(ns\n" "(ns")
                       (str/replace "(:require\n" "(:require")
                       str/split-lines
                       vec)]
  (assoc node :content xf-content)))

(defn clean-namespace-decls
  [org]
  (let [org-zipper (org/zip org)]
    (tree-edit org-zipper match-ns? clean-namespace-decl)))

;; gdaythisisben from Twitch
;; (__(o_o)__)
;; meditating with parens
#+end_src

** src-editor
Some vars are unneeded in a Browser context, like an svg! fn which spits a file so that org-mode can render it in the document. The idea is to edit all src nodes and replace these var definitions and invocations with commented versions. This leaves the source basically intact yet doesn't lead to invalid code in the browser.

#+begin_src clojure :tangle ./src/radish/main.clj
;; for more trustworthy results, it may be wise to implement this
;; with a proper reader that adjusts the src, instead of simple string replacements
;; for example, this will break if a user has a space between the open paren
;; and the fn name. That may be rare, but it's not impossible, and could be very confusing.
(defn- comment-content
  ([sym-list content] (comment-content (rest sym-list) (first sym-list) content))
  ([sym-list sym content]
   (if sym
     (let [new-content (->> content
                            ;; this can still match incorrect fns...
                            (mapv #(str/replace % (str "(defn " sym) (str "#_(defn " sym)))
                            (mapv #(str/replace % (str "(" sym " ") (str "#_(" sym " "))))]
       (recur (vec (rest sym-list)) (first sym-list) new-content))
     content)))

(defn- comment-src-node
  [sym-list node]
  (let [new-content (comment-content sym-list (:content node))]
    (assoc node :content new-content)))

(defn comment-src-nodes
  [org sym-list]
  (let [sym-list (filterv #(not= (str/trim (name %)) "") sym-list)
        org-zipper (org/zip org)
        edit-fn (partial comment-src-node sym-list)]
    (tree-edit org-zipper match-src? edit-fn)))

#+end_src

** site-build-fns
#+begin_src clojure :tangle ./src/radish/main.clj
(defn src-fn
  [x]
  (let [class (str "src-" (first (:attribs x)))]
    [:div.code-container
     [:pre {:class class} (str/join "\n" (:content x))]]))

(defn org-content*
  [org-str]
  (let [title (get-title org-str)
        author (get-author org-str)
        config (get-radish-config org-str)]
    (-> org-str
        org/parse-str
        retag-deps
        remove-results
        clean-namespace-decls
        (comment-src-nodes (:exclude-fns config))
        hiccupify)))

(defn org-content
  [org-str]
  (let [title (get-title org-str)
        author (get-author org-str)
        config (get-radish-config org-str)]
    (list
     [:header [:h1 title]]
     [:main (-> org-str
                org/parse-str
                retag-deps
                remove-results
                clean-namespace-decls
                (comment-src-nodes (:exclude-fns config))
                hiccupify)]
     [:footer
      (when author
        [:p "Written by " [:span {:style {:font-style "italic"}} author]])
      [:p "Generated by "
       [:span {:style {:font-weight "bold"}}
        [:a {:href "https://github.com/adam-james-v/radish"} "radish"]]]])))

(defn org->site
  ([org-str] (org->site org-str nil))
  ([org-str advanced?]
   (let [title (get-title org-str)
         author (get-author org-str)
         org-content (into [:body] (org-content org-str))
         code-runner-str (slurp (clojure.java.io/resource "code-runner.cljs"))]
     (page/html5
      [:head
       [:meta {:charset "utf-8"}]
       [:title title]
       (page/include-css
        "style.css"
        "codemirror.css"
        "nord.css")
       (page/include-js
        "codemirror.js"
        "clojure.js")
       ;; Always include React and ReactDOM
       (page/include-js
        "https://unpkg.com/react@17/umd/react.production.min.js"
        "https://unpkg.com/react-dom@17/umd/react-dom.production.min.js")
       (if advanced?
         ;; include compiled js
         (page/include-js
          "radish.js"
          "radish.reagent.js")
         ;; use scittle for basic build
         (page/include-js
          "https://cdn.jsdelivr.net/gh/borkdude/scittle@0.0.2/js/scittle.js"
          "https://cdn.jsdelivr.net/gh/borkdude/scittle@0.0.2/js/scittle.reagent.js"))
       [:script {:type "application/x-scittle"}
        (if advanced?
          (str/replace code-runner-str "js/scittle.core.eval_string" "js/radish.core.eval_string")
          code-runner-str)]]
      org-content))))

(defn- rand-col
  []
  (str "rgb("
       (+ 100 (rand-int 155)) ","
       (+ 100 (rand-int 155)) ","
       (+ 100 (rand-int 155)) ")"))

(defn- rand-cols-css
  []
  (str/join "\n" [":root {"
                  "  --bg: #ffecdc;"
                  (str "  --col01: " (rand-col) ";")
                  (str "  --col02: " (rand-col) ";")
                  (str "  --col03: " (rand-col) ";")
                  (str "  --col04: " (rand-col) ";")
                  "}\n\n"]))
#+end_src

** basic-build
#+begin_src clojure :tangle ./src/radish/main.clj
(defn basic-build!
  [org-str]
  (let [name (safe-name (get-title org-str))
        index (binding [*user-src-fn* src-fn] (org->site org-str))
        style (str (rand-cols-css)
                   (slurp (clojure.java.io/resource "shared/style.css")))]
    (sh "mkdir" "-p" name)
    (doseq [file ["codemirror.css"
                  "nord.css"
                  "codemirror.js"
                  "clojure.js"]]
      (spit (str name "/" file) (slurp (clojure.java.io/resource (str "shared/" file)))))
    (spit (str name "/style.css") style)
    (spit (str name "/index.html") index)))
#+end_src

** advanced-build
#+begin_src clojure :tangle ./src/radish/main.clj
;; extra deps for the shadow-cljs compilation
(def cljs-deps
  '{borkdude/sci         {:mvn/version "0.2.6"}
    reagent/reagent {:mvn/version "1.0.0"}
    thheller/shadow-cljs {:mvn/version "2.14.0"}
    cljsjs/react {:mvn/version "17.0.2-0"}
    cljsjs/react-dom {:mvn/version "17.0.2-0"}
    cljsjs/react-dom-server {:mvn/version "17.0.2-0"}})

;; deps to dissoc b/c they won't work or aren't needed in the browser
(def clj-deps ['hiccup/hiccup
               'org.clojure/clojure
               'org.clojure/tools.cli])

(defn prepare-deps
  [org-str]
  (-> (get-deps org-str)
      (update :deps (partial apply dissoc) clj-deps)
      (update :deps merge cljs-deps)))

(defn prepare-namespace
  [org-str]
  (->> org-str
       get-namespace-requires
       (remove blacklisted-namespaces)
       vec))

(defn- ns-publics-wrap
  [sym]
  `(ns-publics '~sym))

(defn- ns-symbol-wrap
  [sym]
  `'~(identity sym))

(defn radish-ns-src-str
  [org-str]
  (let [reqs (prepare-namespace org-str)
        req-fn #(apply assoc {} ((juxt ns-symbol-wrap ns-publics-wrap) %))
        req-maps (map req-fn reqs)]
    (str/join "\n"
              ["(ns radish.radns"
               (str (seq (concat [:require] (map vector reqs))) ")")
               "(def my-ns-map"
               (str (apply merge req-maps) ")")])))

(defn shadow-cljs-config
  [org-str]
  (let [name (safe-name (get-title org-str))]
    {:builds
     {:main
      {:target :browser
       :js-options
       {:resolve {"react" {:target :global
                           :global "React"}
                  "react-dom" {:target :global
                               :global "ReactDOM"}}}
       :modules
       {:radish {:entries ['radish.core]}
        :radish.reagent {:entries ['radish.reagent]
                         :depends-on #{:radish}}}
       :output-dir "compiled"
       :devtools   {:repl-pprint true}}}}))

(defn- prepare-radish-project!
  [org-str]
  (let [name (str (safe-name (get-title org-str)) "-build")
        src-dest  (str name "/src/radish")]
    (sh "mkdir" "-p" name)
    (sh "mkdir" "-p" src-dest)
    
    (doseq [file ["core.cljs"
                  "error.cljs"
                  "reagent.cljs"]]
      (spit (str name "/src/radish/" file)
            (slurp (clojure.java.io/resource (str "advanced/" file)))))

    (spit (str name "/package.json") "{}")
    (spit (str name "/shadow-cljs.edn") (shadow-cljs-config org-str))
    (spit (str name "/deps.edn") (prepare-deps org-str))
    (spit (str name "/src/radish/radns.cljs") (radish-ns-src-str org-str))))

(defn- run-radish-build!
  [org-str]
  (prepare-radish-project! org-str)
  (let [name (str (safe-name (get-title org-str)) "-build")
        config (shadow-cljs-config org-str)]
    ;; don't know how to do this within same process yet
    (sh "/usr/local/bin/clojure" "-M" "-m" "shadow.cljs.devtools.cli" "release" ":main"
        :dir name)))

(defn advanced-build!
  [org-str]
  (let [name (safe-name (get-title org-str))
        build-name (str name "-build")
        index (binding [*user-src-fn* src-fn] (org->site org-str :advanced))
        style (str (rand-cols-css)
                   (slurp (clojure.java.io/resource "shared/style.css")))]
    (run-radish-build! org-str)
    (sh "mkdir" "-p" name)
    (sh "cp"
        (str build-name "/compiled/radish.js")
        (str build-name "/compiled/radish.reagent.js")
        name)
    (sh "rm" "-rf" build-name)
    (doseq [file ["codemirror.css"
                  "nord.css"
                  "codemirror.js"
                  "clojure.js"]]
      (spit (str name "/" file) (slurp (clojure.java.io/resource (str "shared/" file)))))
    (spit (str name "/style.css") style)
    (spit (str name "/index.html") index)))

#+end_src

** cli
#+begin_src clojure :tangle ./src/radish/main.clj
(def cli-options
  [["-i" "--infile FNAME" "The file to be compiled."
    :default nil]
   ["-h" "--help"]])

(defn- requires-advanced?
  [org-str]
  (let [org (org/parse-str org-str)]
    (not (empty? (get-nodes (org/zip org) match-deps?)))))

(defn -main
  [& args]
  (let [parsed (cli/parse-opts args cli-options)
        {:keys [:infile :help]} (:options parsed)
        [in _] (when infile (str/split infile #"\."))
        ]
    (cond
      help
      (do (println "Usage:")
          (println (:summary parsed)))
          
      (nil? infile)
      (println "Please specify an input file")
      
      :else
      (let [org-str (slurp infile)
            outdir (safe-name (get-title org-str))
            msg (str "\nCompiling " infile " into directory " outdir ".")]
        (if (requires-advanced? org-str)
          (do
            (println "Detected external dependencies, running advanced build.")
            (println msg)
            (advanced-build! org-str))
          (do
            (println "No external dependencies detected, running basic build.")
            (println msg)
            (basic-build! org-str)))
        (println "Success! Have a nice day :)"))))
  ;; sh uses futures in different threads, so shut them down to prevent delayed exit
  ;; calling sh in REPL doesn't have the hanging issue, so shutdown agents here.
  (shutdown-agents))
#+end_src

* tests
Run the tests and see results in the org file:

#+begin_src bash
clj -M:test
#+end_src

** code-runner
The code-runner is only run in browser, but should still have a few tests.

#+begin_src clojure :tangle ./test/radish/code_runner_test.clj
(ns radish.code-runner-test
  (:require [clojure.test :as t :refer [deftest is]]
            [clojure.string :as str]))

;; cheeky hack to get two fns from the script
(def code-runner-src
  (let [src-str (str/replace
                 (slurp "resources/code-runner.cljs") #"#js" "")]
    (filter
     (fn [[_ sym & _]]
       (#{'renderable-element?
          'renderable?} sym))
     (read-string (str "[" src-str "]")))))

(doseq [f code-runner-src] (eval f))

(deftest renderable
  (is (renderable? [:asdf]))
  (is (renderable? [:circle {:r 20}]))
  (is (renderable? [:p]))
  (is (renderable? [:p "hello"]))
  (is (renderable? [:p {:style {:color "blue"}} "hello"]))
  (is (renderable? [:div [:p "hello"]]))
  (is (renderable? [:div (repeat 10 [:p "hello"])]))
  (is (not (renderable? [])))
  (is (not (renderable? [:3 "weird"])))
  (is (not (renderable? [:!ab "weird"])))
  (is (not (renderable? [:a!b "weird"])))
  (is (not (renderable? [:ab! "weird"])))
  (is (not (renderable? [:a$b "weird"])))
  (is (not (renderable? [:ab$ "weird"])))
  (is (not (renderable? [:a%b "weird"])))
  (is (not (renderable? [:ab% "weird"])))
  (is (not (renderable? [:a&b "weird"])))
  (is (not (renderable? [:ab& "weird"])))
  (is (not (renderable? [:a*b "weird"])))
  (is (not (renderable? [:ab* "weird"])))
  (is (not (renderable? [:a|b "weird"])))
  (is (not (renderable? [:ab| "weird"])))
  (is (not (renderable? [:a/b "weird"])))
  (is (not (renderable? (list :p "hi"))))
  (is (not (renderable? ["asdf" "wasd"])))
  (is (not (renderable? [[:p "hi"]])))
  (is (not (renderable? [[:p "hi"] [:p "hello"]]))))

#+end_src

** main
#+begin_src clojure :tangle ./test/radish/main_test.clj
(ns radish.main-test
  (:require [clojure.test :as t :refer [deftest is]]
            [radish.main :as rad]))

(def get-title-test-org-strs
  {:a "* ;;\n#+Title: Found Title\n#+AUTHOR: adam-james\n\n* Found Headline as Title\nContent goes here...\n"
   :b "* ;;\n#+AUTHOR: adam-james\n\n* Found Headline as Title\nContent goes here...\n"
   :c "* Valid First Headline\n#+Title: Found Title\n#+AUTHOR: adam-james\n\n* Found Headline as Title\nContent goes here...\n"
   :d "* Valid First Headline\n#+AUTHOR: adam-james\n\n* Found Headline as Title\nContent goes here...\n"
   :e "* Valid First Headline\n#+Title: Found Title\n#+AUTHOR: adam-james\n\n* Found Headline as Title\nContent goes here...\n"
   :f (slurp "radish.org")})

(deftest get-title-test
  (is (= (rad/get-title (:a get-title-test-org-strs)) "Found Title"))
  (is (= (rad/get-title (:b get-title-test-org-strs)) "Found Headline as Title"))
  (is (= (rad/get-title (:c get-title-test-org-strs)) "Found Title"))
  (is (= (rad/get-title (:d get-title-test-org-strs)) "Valid First Headline"))
  (is (= (rad/get-title (:e get-title-test-org-strs)) "Found Title"))
  (is (= (rad/get-title (:f get-title-test-org-strs)) "radish")))

(deftest get-deps-test
  (is (= (rad/get-deps (slurp "radish.org"))
         '{:deps
          {org.clojure/clojure #:mvn{:version "1.10.3"},
           org.clojure/tools.cli #:mvn{:version "1.0.206"},
           hiccup/hiccup #:mvn{:version "2.0.0-alpha2"},
           orgmode/orgmode
           {:git/url "https://github.com/bnbeckwith/orgmode",
            :sha "722972c72b43c18a5cdbbc9c3e392b5ee9e2b503"}}})))

#+end_src
